---
layout: post
title: "Lecture 2 : Approximate Heavy Hitters and the Count-Min Sketch"
---

## The Heavy Hitters Problem

### Finding the Majority Element

Let's begin with a problem that many of you have seen before.
It's a common question in technical interviews.  You're given as
input an array $$A$$ of length $$n$$, with the promise that it has a *majority element* --- a value that is repeated in strictly more than
$$n/2$$ of the array's entries.  Your task is to find the majority element.

In algorithm design, the usual "holy grail" is a linear-time
algorithm.  For this problem, your post-CS161 toolbox already contains
a subroutine that gives a linear-time solution --- just compute the
median of $$A$$.  (Note: it must be the majority element.)  So let's be
more ambitious: can we compute the majority element with a single
left-to-right pass through the array?
If you haven't seen it before, here's the solution:

* Initialize counter := 0, current := NULL. 
  [current stores the frontrunner for the majority element]

* For $$i=1$$ to $$n$$:

     * If counter == 0:
     
       [In this case, there is no frontrunner.]

          * current := A[i]

          * counter++

     * else if A[i]==current:

       [In this case, our confidence in the current frontrunner goes up.]

          * counter++

     * else

       [In this case, our confidence in the current frontrunner goes down.]

          * counter- -

* Return current

For example, suppose the input is the array $$\{2,1,1\}$$.  The first
iteration of the algorithm makes "2" the current guess of the majority
element, and sets the counter to 1.  The next element decreases the
counter back to 0 (since $$1 \neq 2$$).  The final iteration resets the
current guess to "1" (with counter value 1), which is indeed the
majority element.

More generally, the algorithm correctly computes the majority element
of any array that possesses one.  We encourage you to formalize a
proof of this statement (e.g., by induction on $$n$$).  The intuition is
that each entry of $$A$$ that
contains a non-majority-value can only "cancel out" one copy of the
majority value.  Since more than $$n/2$$ of the entries of $$A$$
contain the majority value, there is guaranteed to be a copy of it
left standing at the end of the algorithm.

But so what?  It's a cute algorithm, but isn't this just a toy
problem?  It is, but modest generalizations of the problem are quite
close to problems that people really want to solve in practice.

### The Heavy Hitters Problem

In the *heavy hitters* problem, the input is an array $$A$$ of
length $$n$$, and also a parameter $$k$$.  You should think of $$n$$ as very
large (in the hundreds of millions, or billions), and $$k$$ as modest
(10, 100, or 1000). The goal is to compute the values that occur in the array at
least $$n/k$$ times.[^1] Note that there can be at most $$k$$ such values; and there might be
none. The problem of computing the majority element corresponds to the heavy hitters
problem with $$k \approx 2-\delta$$ for a small value $$\delta > 0$$, and
with the additional promise that a majority element exists.

[^1]: A similar problem is the "top-$$k$$ problem," where the goal is to output the $$k$$ values that occur with the highest frequencies.  The algorithmic ideas introduced in this lecture are also relevant for the top-$$k$$ problem.

The heavy hitters problem has lots of applications, as you can
imagine.  We'll be more specific later when we discuss a concrete
solution, but here are some high-level examples: [^2]

[^2]: You wouldn't expect there to be a majority element in any of these applications, but you might expect a non-empty set of heavy hitters when $$k$$ is 100, 1000, or 10000.

1. Computing popular products.  For example, $$A$$ could be all of
  the page views of products on [amazon]{http://www.amazon.com} yesterday. The heavy
  hitters are then the most frequently viewed products.

2. Computing frequent search queries.  For example, $$A$$ could be
  all of the searches on Google yesterday.  The heavy
  hitters are then searches made most often.

3. Identifying heavy TCP flows.  Here, $$A$$ is a list of data packets passing through a network switch, each annotated with a source-destination pair of IP addresses.  The heavy hitters are then the flows that are sending the most traffic.  This is useful for, among other things, identifying denial-of-service attacks.

4. Identifying volatile stocks.  Here, $$A$$ is a list of stock
  trades.

It's easy to think of more.  Clearly, it would be nice to have a
good algorithm for the heavy hitters problem at your disposal for data
analysis.

The problem is easy to solve efficiently if $$A$$ is readily available
in main memory --- just sort the array and do a linear scan over the result,
outputting a value if and only if it occurs (consecutively) at least
$$n/k$$ times.
After being spoiled by our slick solution for finding a majority element, we
naturally want to do better.  Can we solve the heavy hitters problem
with a single pass over the array?
This question isn't posed quite
correctly, since it allows us to cheat: we could make a single pass
over the array, make a local copy of it in our working memory, and
then apply the sorting-based solution to our local copy.  Thus what we
mean is: can we solve the Heavy Hitters problem with a single pass
over the array, using only a small amount of auxiliary
space?[^3]

[^3]: Rather than thinking of the array $$A$$ as an input fully specified in advance, we can alternatively think of the elements of $$A$$ as a "data stream," which are fed to a "streaming algorithm" one element at a time. One-pass algorithms that use small auxiliary space translate to streaming algorithms that need only small working memory. One use case for streaming algorithms is when data arrives at such a fast rate that explicitly storing it is absurd. For example, this  is often the reality in the motivating example of data packets traveling through a network switch. A second use case is when, even though data can be stored in its entirety and fully analyzed (perhaps as an overnight job), it's still useful to perform lightweight analysis on the arriving data in real time. The first two applications (popular transactions or search queries) are examples of this.

###  An Impossibility Result

The following fact might surprise you.

**Fact 1.1** *There is* no *algorithm that solves the Heavy Hitters problems in one pass
while using a sublinear amount of auxiliary space.*
{: #fact1}

We next explain the intuition behind [Fact 1.1](#fact1).  We encourage
you to devise a formal proof, which follows the same lines as the
intuition.

Set $$k = n/2$$, so that our responsibility is to output any values that
occur at least twice in the input array $$A$$.[^4]

Suppose $$A$$ has the form

$$ \underbrace{|x_1|x_2|x_3|\cdots|x_{n-1}|}_{\text{set } S \text{ of distinct elements}}y|, $$

[^4]:A simple modification of this argument extends the impossibility result to all interesting values of $$k$$ --- can you figure it out?

where $$x_1,\ldots,x_{n-1} $$ are an arbitrary set $$S$$ of distinct
elements (in $$\{1,2,\ldots,n^2\}$$, say) and the
final entry $$y$$ may or may not be in $$S$$.  By definition,
we need to output $$y$$ if and only if $$y \in S$$.
That is, *answering membership queries reduces
to solving the Heavy Hitters problem.*

By the "membership problem", we mean the task of preprocessing a set
$$S$$ to answer queries of the form "is $$y \in S$$"? (A hash table is the most common solution to this problem.)
It is intuitive that you cannot correctly answer all membership queries for a set $$S$$
without storing $$S$$ (thereby using linear, rather than constant, space)
--- if you throw some of $$S$$ out, you might get a query asking about
the part you threw out, and you won't know the answer.  It's not too
hard to make this idea precise using the Pigeonhole Principle.[^5]


[^5]: Somewhat more detail: if you always use sublinear space to store the set $$S$$, then you need to reuse exactly the same memory contents for two different sets $$S_1$$ and $$S_2$$. Your membership query answers will be the same in both cases, and in one of these cases some of your answers will be wrong.








